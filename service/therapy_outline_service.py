import os
from typing import List, Optional

from dotenv import load_dotenv

from constant import EnvKeys
from helper import Logger
from model.user import User
from repository import TherapyOutlineRepository
from service import MemoryService
from model import TherapyOutline, Step, Memory
from openai import OpenAI

load_dotenv()


class TherapyOutlineService:
    def __init__(self):
        from service import UserService

        self.user_service = UserService()
        self.memory_service = MemoryService()
        self.therapy_outline_repository = TherapyOutlineRepository()
        self.openai = OpenAI(
            api_key=os.getenv(EnvKeys.OPENAI_API_KEY.value),
        )
        self.logger = Logger(__name__)

    def get_therapy_outline_by_memory_id(self, memory_id: str) -> Optional[TherapyOutline]:
        return self.therapy_outline_repository.get_therapy_outline_by_memory_id(memory_id)

    def get_therapy_outline_by_id(self, therapy_id: str) -> TherapyOutline:
        return self.therapy_outline_repository.get_therapy_outline_by_id(therapy_id)

    def save_therapy_outline(self, patient_id: str, memory_id: str):
        therapy_outline = TherapyOutline(
            patientId=patient_id,
            memoryId=memory_id,
            status="pending",
            steps=[]
        )
        return self.therapy_outline_repository.save_therapy_outline(therapy_outline)

    def delete_existing_therapy_outline(self, memory_id: str):
        therapy_outline = self.get_therapy_outline_by_memory_id(memory_id)
        if therapy_outline:
            self.therapy_outline_repository.delete(therapy_outline.id)

    def update_therapy_outline(self, therapy_id: str, patient_id: str, memory_id: str, status: str, steps: List[Step] = None):
        therapy_outline = TherapyOutline(
            patientId=patient_id,
            memoryId=memory_id,
            status=status,
            steps=steps
        )
        self.therapy_outline_repository.update_therapy_outline_by_id(therapy_id, therapy_outline)

    def generate_and_save_therapy_outline(self, memory: Memory, patient: User, therapy_id: str):
        self.logger.info("Generating therapy outline for memory: %s", memory.id)

        input_data = {
            "memory_id": memory.id,
            "memory_details": memory.model_dump(by_alias=True),
            "patient_details": patient.model_dump(by_alias=True)
        }

        # Generate therapy outline using OpenAI
        outline_json = self._generate_therapy_outline(input_data)

        therapy_outline = TherapyOutline(
            patientId=memory.patientId,
            memoryId=memory.id,
            status="outlined",
            steps=[Step(**step) for step in outline_json["steps"]]
        )

        self.logger.info("Saving therapy outline for memory: %s", memory.id)
        return self.therapy_outline_repository.update_therapy_outline_by_id(therapy_id, therapy_outline)

    def _generate_therapy_outline(self, input_data: dict) -> dict:
        prompt = self._construct_therapy_outline_prompt(input_data)

        # Call OpenAI API
        response = self.openai.chat.completions.create(
            model="gpt-4o",
            messages=[
                {
                    "role": "system",
                    "content": [
                        {
                            "type": "text",
                            "text": "You are an AI assistant specializing in reminiscence therapy."}
                    ]
                },
                {
                    "role": "user",
                    "content": [
                        {
                            "type": "text",
                            "text": prompt
                        }
                    ]
                }
            ],
            temperature=0.2
        )

        # Extract and validate response
        output = response.choices[0].message.content
        self.logger.info("Therapy outline generated by OpenAI: %s", output)
        return self._parse_json_output(output)

    @staticmethod
    def _construct_therapy_outline_prompt(input_data: dict) -> str:
        return f"""
        Generate a therapy outline in the following JSON format:

        {{
          "patientId": "string",
          "memoryId": "string",
          "steps": [
            {{
              "step": "int",
              "description": "string",
              "guide": ["string", "..."],
              "type": "string (introduction, normal, conclusion)",
              "mediaUrls": ["string", "..."],
              "script": {{
                "voice": "string (alloy, echo, fable, onyx, nova, shimmer)",
                "text": "string"
              }}
            }}
          ]
        }}

        Memory Details:
        {input_data["memory_details"]}

        Patient Details:
        {input_data["patient_details"]}

        Requirements:
        - Use the patient details and memory details to generate personalized steps and guidance.
        - Each media item should be associated with at least one step. Some steps may include multiple media items.
        - The number of steps should equal or greater than the number of media files.
        - Include associated media URLs for each step where applicable.
        - Follow a logical structure: introduction, main sessions, conclusion.
        - Provide guidance points for each step in the `guide` field.
        - Each step should include a script with:
          - A calm, relaxing, and therapist-like tone.
          - Simple and empathetic language to guide reflective thinking and encourage memories.
          - Minimize the questioning of the patient. And say more about the given media. and then ask some questions.
          - We need this script to have at least 20-30 seconds of content.
        - Choose one consistent voice for all steps from the following options: alloy, echo, fable, onyx, nova, shimmer.
        - Ensure the JSON format matches the provided structure.
        - Provide the output as a valid JSON object without any extra formatting or code block markers.
        """

    @staticmethod
    def _parse_json_output(output: str) -> dict:
        import json
        try:
            return json.loads(output)
        except json.JSONDecodeError as e:
            raise ValueError(f"Invalid JSON output from OpenAI: {e}")

